    .data
input_prompt:      .asciz "Введите размер массива (от 1 до 10): "  # Сообщение для ввода N
element_prompt:    .asciz "Введите элемент массива A: "   # Сообщение для ввода элемента массива A
output_a:          .asciz "Массив A: "                     # Сообщение для вывода массива A
output_b:          .asciz "Массив B: "                     # Сообщение для вывода массива B
newline:           .asciz "\n"                             # Новая строка
space:             .asciz " "                              # Пробел
error_msg:         .asciz "Неверный ввод. Пожалуйста, введите число от 1 до 10.\n" # Сообщение об ошибке

    .text
    .globl main

# Главная программа
main:
    # Сохраняем содержимое регистров на стеке
    addi    sp, sp, -12      # Выделяем место на стеке (12 байт)
    sw      ra, 8(sp)        # Сохраняем регистр ra (возвратный адрес)
    sw      t0, 4(sp)        # Сохраняем t0 на стеке
    sw      t5, 0(sp)        # Сохраняем t5 на стеке

    # Вводим размер массива N, результат в t0
    call    input_n          # t0 = N

    # Вводим элементы массива A, передаем размер N через t0
    call    input_array_A

    # Выводим массив A, используем размер N из t0
    call    output_array_A

    # Формируем и выводим массив B, передаем N через t0
    call    form_array_B

    # Восстанавливаем сохраненные регистры
    lw      ra, 8(sp)        # Восстанавливаем регистр ra
    lw      t0, 4(sp)        # Восстанавливаем регистр t0
    lw      t5, 0(sp)        # Восстанавливаем регистр t5
    addi    sp, sp, 12       # Освобождаем место на стеке

    j       exit_program      # Завершаем программу

# Подпрограмма для ввода N
# Возвращаемое значение: N в t0
input_n:
    la      a0, input_prompt      # a0 = адрес сообщения для ввода N
    li      a7, 4             # Системный вызов для вывода строки
    ecall

    li      a7, 5             # Системный вызов для чтения целого числа
    ecall
    mv      t0, a0            # t0 = введенное N

    li      t1, 1             # Нижняя граница N
    li      t2, 10            # Верхняя граница N
    blt     t0, t1, error_input  # Если N < 1, повторить ввод
    bgt     t0, t2, error_input  # Если N > 10, повторить ввод
    ret

# Обработка некорректного ввода N
error_input:
    la      a0, error_msg     # a0 = адрес сообщения об ошибке
    li      a7, 4             # Системный вызов для вывода строки
    ecall
    j       input_n           # Повторный ввод N

# Подпрограмма для ввода массива A
# Использует t0 как N
input_array_A:
    li      t3, 0             # t3 = индекс массива A (0)
    la      t4, array_A       # t4 = адрес начала массива A
input_loop:
    bge     t3, t0, ret_input # Если t3 >= N, завершение ввода

    # Сохраняем временные регистры на стеке
    addi    sp, sp, -8        # Выделяем место на стеке (8 байт)
    sw      t3, 4(sp)         # Сохраняем t3 на стеке
    sw      t4, 0(sp)         # Сохраняем t4 на стеке

    # Выводим запрос на ввод элемента массива A
    la      a0, element_prompt      # a0 = адрес сообщения для ввода элемента
    li      a7, 4             # Системный вызов для вывода строки
    ecall

    # Читаем элемент массива A
    li      a7, 5             # Системный вызов для чтения целого числа
    ecall
    sw      a0, 0(t4)         # Сохраняем введенное значение в массив A

    # Восстанавливаем временные регистры
    lw      t3, 4(sp)         # Восстанавливаем t3
    lw      t4, 0(sp)         # Восстанавливаем t4
    addi    sp, sp, 8         # Освобождаем место на стеке

    # Переходим к следующему элементу
    addi    t4, t4, 4         # t4 = t4 + 4
    addi    t3, t3, 1         # t3 = t3 + 1
    j       input_loop        # Переходим к следующей итерации
ret_input:
    ret

# Подпрограмма для вывода массива A
# Использует t0 как N
output_array_A:
    la      a0, output_a      # a0 = адрес сообщения для вывода массива A
    li      a7, 4
    ecall
li      t3, 0             # t3 = индекс массива A (0)
    la      t4, array_A       # t4 = адрес начала массива A
output_loop_A:
    bge     t3, t0, ret_output_A  # Если t3 >= N, завершение вывода

    # Сохраняем временные регистры на стеке
    addi    sp, sp, -8        # Выделяем место на стеке (8 байт)
    sw      t3, 4(sp)         # Сохраняем t3 на стеке
    sw      t4, 0(sp)         # Сохраняем t4 на стеке

    lw      a0, 0(t4)         # Загружаем элемент массива A в a0
    li      a7, 1             # Системный вызов для вывода целого числа
    ecall

    la      a0, space         # Выводим пробел
    li      a7, 4
    ecall

    # Восстанавливаем временные регистры
    lw      t3, 4(sp)         # Восстанавливаем t3
    lw      t4, 0(sp)         # Восстанавливаем t4
    addi    sp, sp, 8         # Освобождаем место на стеке

    # Переходим к следующему элементу
    addi    t4, t4, 4
    addi    t3, t3, 1
    j       output_loop_A
ret_output_A:
    la      a0, newline       # Печатаем новую строку
    li      a7, 4
    ecall
    ret

# Подпрограмма для формирования и вывода массива B
# Использует t0 как N
form_array_B:
    la      a0, output_b      # a0 = адрес сообщения для вывода массива B
    li      a7, 4
    ecall

    # Сортируем массив A в порядке возрастания
    call    sort_array_A

    # Создаем массив B, сохраняя индексы отсортированных элементов из массива A
    li      t3, 0             # t3 = индекс для массива B
    la      t4, array_A       # t4 = адрес начала массива A
    la      t6, array_B       # t6 = адрес начала массива B

create_array_B:
    bge     t3, t0, print_array_B  # Если t3 >= N, завершение создания массива B

    sw      t3, 0(t6)         # Сохраняем индекс в массиве B

    # Переходим к следующему элементу
    addi    t6, t6, 4
    addi    t3, t3, 1
    j       create_array_B

print_array_B:
    # Выводим элементы массива A в порядке, указанном в массиве B
    li      t3, 0             # t3 = индекс для массива B
    la      t6, array_B       # t6 = адрес начала массива B

print_loop_B:
    bge     t3, t0, ret_output_B  # Если t3 >= N, завершение вывода

    lw      t5, 0(t6)         # Загружаем индекс из массива B
    slli    t5, t5, 2         # t5 = t5 * 4 (смещение в байтах)
    add     t4, t4, t5        # t4 = адрес элемента в массиве A

    lw      a0, 0(t4)         # Загружаем элемент из массива A

    # Выводим элемент массива A
    li      a7, 1
    ecall

    la      a0, space         # Выводим пробел
    li      a7, 4
    ecall

    # Переходим к следующему элементу
    li      t5, 0             # Сбрасываем индекс для массива A
    la      t4, array_A       # Сбрасываем адрес начала массива A
    addi    t6, t6, 4
    addi    t3, t3, 1
    j       print_loop_B
ret_output_B:
    la      a0, newline       # Печатаем новую строку
    li      a7, 4
    ecall
    ret

# Подпрограмма для сортировки массива A в порядке возрастания
# Использует t0 как N
sort_array_A:
    li      t1, 0             # t1 = индекс i
sort_loop_i:
    bge     t1, t0, ret_sort  # Если t1 >= N, завершение сортировки

    li      t2, 0             # t2 = индекс j
    li      t3, 1             # t3 = t2 + 1
sort_loop_j:
    bge     t3, t0, next_i    # Если t3 >= N, переходим к следующему i

    # Сравниваем элементы массива A[j] и A[j+1]
    slli    t4, t2, 2         # t4 = t2 * 4 (смещение в байтах)
    la      t5, array_A       # t5 = адрес начала массива A
    add     t5, t5, t4        # t5 = адрес элемента A[j]
    lw      t6, 0(t5)         # t6 = элемент A[j]

    slli    t4, t3, 2         # t4 = t3 * 4 (смещение в байтах)
    la      t5, array_A       # t5 = адрес начала массива A
    add     t5, t5, t4        # t5 = адрес элемента A[j+1]
    lw      s0, 0(t5)         # s0 = элемент A[j+1]

    ble     t6, s0, next_j    # Если A[j] <= A[j+1], переходим к следующему j

    # Меняем местами элементы A[j] и A[j+1]
    slli    t4, t2, 2         # t4 = t2 * 4 (смещение в байтах)
    la      t5, array_A       # t5 = адрес начала массива A
    add     t5, t5, t4        # t5 = адрес элемента A[j]
    sw      s0, 0(t5)         # Сохраняем элемент A[j+1] в A[j]

    slli    t4, t3, 2         # t4 = t3 * 4 (смещение в байтах)
    la      t5, array_A       # t5 = адрес начала массива A
    add     t5, t5, t4        # t5 = адрес элемента A[j+1]
    sw      t6, 0(t5)         # Сохраняем элемент A[j] в A[j+1]

next_j:
    # Переходим к следующему j
    addi    t2, t2, 1
    addi    t3, t3, 1
    j       sort_loop_j

next_i:
    # Переходим к следующему i
    addi    t1, t1, 1
    j       sort_loop_i
ret_sort:
    ret

# Завершение программы
exit_program:
    li      a7, 10            # Системный вызов для завершения программы
    ecall

    .data
    .align 2
array_A: .space 40  # Массив A (10 элементов по 4 байта)
array_B: .space 40  # Массив B (10 элементов по 4 байта)
